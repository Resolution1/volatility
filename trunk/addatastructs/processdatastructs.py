#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Aug 13 09:11:19 2014 by generateDS.py version 2.12e.
#
# Command line options:
#   ('-o', 'processdatastructure.py')
#   ('--external-encoding', 'utf-8')
#
# Command line arguments:
#   .\process.xsd
#
# Command line:
#   C:\Python27\Scripts\generateDS.py -o "processdatastructure.py" --external-encoding="utf-8" .\process.xsd
#
# Current working directory (os.getcwd()):
#   autogenerate
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_
import adutils as utils

def _safe_encode(text):
    try:
        encoded_str = text.encode(ExternalEncoding)
    except UnicodeDecodeError:
        try:
            encoded_str = utils.SmartUnicode(text).encode("utf-8", "replace")
        except Exception as e:
            encoded_str = "EXCEPTION: " + str(e)
    return encoded_str

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class root(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Process=None):
        self.original_tagname_ = None
        if Process is None:
            self.Process = []
        else:
            self.Process = Process
    def factory(*args_, **kwargs_):
        if root.subclass:
            return root.subclass(*args_, **kwargs_)
        else:
            return root(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Process(self): return self.Process
    def set_Process(self, Process): self.Process = Process
    def add_Process(self, value): self.Process.append(value)
    def insert_Process_at(self, index, value): self.Process.insert(index, value)
    def replace_Process_at(self, index, value): self.Process[index] = value
    def hasContent_(self):
        if (
            self.Process
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='root', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='root')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='root', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='root'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='root', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Process_ in self.Process:
            Process_.export(outfile, level, namespace_, name_='Process', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='root'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Process=[\n')
        level += 1
        for Process_ in self.Process:
            showIndent(outfile, level)
            outfile.write('model_.ProcessType(\n')
            Process_.exportLiteral(outfile, level, name_='ProcessType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Process':
            obj_ = ProcessType.factory()
            obj_.build(child_)
            self.Process.append(obj_)
            obj_.original_tagname_ = 'Process'
# end class root


class ProcessType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resultitemtype=None, Name=None, Path=None, StartTime=None, WorkingDir=None, CommandLine=None, LinkTime=None, Subsystem=None, Imagebase=None, Characteristics=None, Checksum=None, KernelTime=None, UserTime=None, Privileges=None, PID=None, ParentPID=None, User=None, Group=None, MD5=None, SHA1=None, FuzzySize=None, Fuzzy=None, Fuzzy2X=None, KFFStatus=None, Hidden=None, FromMemory=None, EffectiveUser=None, EffectiveGroup=None, Size=None, EProcBlockLoc=None, WindowTitle=None, SDT=None, Open_Sockets_List=None, Loaded_DLL_List=None, Open_Handles_List=None, Vad_List=None, YaraHits=None):
        self.original_tagname_ = None
        self.resultitemtype = _cast(int, resultitemtype)
        self.Name = Name
        self.Path = Path
        self.StartTime = StartTime
        self.WorkingDir = WorkingDir
        self.CommandLine = CommandLine
        self.LinkTime = LinkTime
        self.Subsystem = Subsystem
        self.Imagebase = Imagebase
        self.Characteristics = Characteristics
        self.Checksum = Checksum
        self.KernelTime = KernelTime
        self.UserTime = UserTime
        self.Privileges = Privileges
        self.PID = PID
        self.ParentPID = ParentPID
        self.User = User
        self.Group = Group
        self.MD5 = MD5
        self.SHA1 = SHA1
        self.FuzzySize = FuzzySize
        self.Fuzzy = Fuzzy
        self.Fuzzy2X = Fuzzy2X
        self.KFFStatus = KFFStatus
        self.Hidden = Hidden
        self.FromMemory = FromMemory
        self.EffectiveUser = EffectiveUser
        self.EffectiveGroup = EffectiveGroup
        self.Size = Size
        self.EProcBlockLoc = EProcBlockLoc
        self.WindowTitle = WindowTitle
        if SDT is None:
            self.SDT = []
        else:
            self.SDT = SDT
        self.Open_Sockets_List = Open_Sockets_List
        self.Loaded_DLL_List = Loaded_DLL_List
        self.Open_Handles_List = Open_Handles_List
        self.Vad_List = Vad_List
        self.YaraHits = YaraHits
    def factory(*args_, **kwargs_):
        if ProcessType.subclass:
            return ProcessType.subclass(*args_, **kwargs_)
        else:
            return ProcessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Path(self): return self.Path
    def set_Path(self, Path): self.Path = Path
    def get_StartTime(self): return self.StartTime
    def set_StartTime(self, StartTime): self.StartTime = StartTime
    def get_WorkingDir(self): return self.WorkingDir
    def set_WorkingDir(self, WorkingDir): self.WorkingDir = WorkingDir
    def get_CommandLine(self): return self.CommandLine
    def set_CommandLine(self, CommandLine): self.CommandLine = CommandLine
    def get_LinkTime(self): return self.LinkTime
    def set_LinkTime(self, LinkTime): self.LinkTime = LinkTime
    def get_Subsystem(self): return self.Subsystem
    def set_Subsystem(self, Subsystem): self.Subsystem = Subsystem
    def get_Imagebase(self): return self.Imagebase
    def set_Imagebase(self, Imagebase): self.Imagebase = Imagebase
    def get_Characteristics(self): return self.Characteristics
    def set_Characteristics(self, Characteristics): self.Characteristics = Characteristics
    def get_Checksum(self): return self.Checksum
    def set_Checksum(self, Checksum): self.Checksum = Checksum
    def get_KernelTime(self): return self.KernelTime
    def set_KernelTime(self, KernelTime): self.KernelTime = KernelTime
    def get_UserTime(self): return self.UserTime
    def set_UserTime(self, UserTime): self.UserTime = UserTime
    def get_Privileges(self): return self.Privileges
    def set_Privileges(self, Privileges): self.Privileges = Privileges
    def get_PID(self): return self.PID
    def set_PID(self, PID): self.PID = PID
    def get_ParentPID(self): return self.ParentPID
    def set_ParentPID(self, ParentPID): self.ParentPID = ParentPID
    def get_User(self): return self.User
    def set_User(self, User): self.User = User
    def get_Group(self): return self.Group
    def set_Group(self, Group): self.Group = Group
    def get_MD5(self): return self.MD5
    def set_MD5(self, MD5): self.MD5 = MD5
    def get_SHA1(self): return self.SHA1
    def set_SHA1(self, SHA1): self.SHA1 = SHA1
    def get_FuzzySize(self): return self.FuzzySize
    def set_FuzzySize(self, FuzzySize): self.FuzzySize = FuzzySize
    def get_Fuzzy(self): return self.Fuzzy
    def set_Fuzzy(self, Fuzzy): self.Fuzzy = Fuzzy
    def get_Fuzzy2X(self): return self.Fuzzy2X
    def set_Fuzzy2X(self, Fuzzy2X): self.Fuzzy2X = Fuzzy2X
    def get_KFFStatus(self): return self.KFFStatus
    def set_KFFStatus(self, KFFStatus): self.KFFStatus = KFFStatus
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def get_FromMemory(self): return self.FromMemory
    def set_FromMemory(self, FromMemory): self.FromMemory = FromMemory
    def get_EffectiveUser(self): return self.EffectiveUser
    def set_EffectiveUser(self, EffectiveUser): self.EffectiveUser = EffectiveUser
    def get_EffectiveGroup(self): return self.EffectiveGroup
    def set_EffectiveGroup(self, EffectiveGroup): self.EffectiveGroup = EffectiveGroup
    def get_Size(self): return self.Size
    def set_Size(self, Size): self.Size = Size
    def get_EProcBlockLoc(self): return self.EProcBlockLoc
    def set_EProcBlockLoc(self, EProcBlockLoc): self.EProcBlockLoc = EProcBlockLoc
    def get_WindowTitle(self): return self.WindowTitle
    def set_WindowTitle(self, WindowTitle): self.WindowTitle = WindowTitle
    def get_SDT(self): return self.SDT
    def set_SDT(self, SDT): self.SDT = SDT
    def add_SDT(self, value): self.SDT.append(value)
    def insert_SDT_at(self, index, value): self.SDT.insert(index, value)
    def replace_SDT_at(self, index, value): self.SDT[index] = value
    def get_Open_Sockets_List(self): return self.Open_Sockets_List
    def set_Open_Sockets_List(self, Open_Sockets_List): self.Open_Sockets_List = Open_Sockets_List
    def get_Loaded_DLL_List(self): return self.Loaded_DLL_List
    def set_Loaded_DLL_List(self, Loaded_DLL_List): self.Loaded_DLL_List = Loaded_DLL_List
    def get_Open_Handles_List(self): return self.Open_Handles_List
    def set_Open_Handles_List(self, Open_Handles_List): self.Open_Handles_List = Open_Handles_List
    def get_Vad_List(self): return self.Vad_List
    def set_Vad_List(self, Vad_List): self.Vad_List = Vad_List
    def get_YaraHits(self): return self.YaraHits
    def set_YaraHits(self, YaraHits): self.YaraHits = YaraHits
    def get_resultitemtype(self): return self.resultitemtype
    def set_resultitemtype(self, resultitemtype): self.resultitemtype = resultitemtype
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Path is not None or
            self.StartTime is not None or
            self.WorkingDir is not None or
            self.CommandLine is not None or
            self.LinkTime is not None or
            self.Subsystem is not None or
            self.Imagebase is not None or
            self.Characteristics is not None or
            self.Checksum is not None or
            self.KernelTime is not None or
            self.UserTime is not None or
            self.Privileges is not None or
            self.PID is not None or
            self.ParentPID is not None or
            self.User is not None or
            self.Group is not None or
            self.MD5 is not None or
            self.SHA1 is not None or
            self.FuzzySize is not None or
            self.Fuzzy is not None or
            self.Fuzzy2X is not None or
            self.KFFStatus is not None or
            self.Hidden is not None or
            self.FromMemory is not None or
            self.EffectiveUser is not None or
            self.EffectiveGroup is not None or
            self.Size is not None or
            self.EProcBlockLoc is not None or
            self.WindowTitle is not None or
            self.SDT or
            self.Open_Sockets_List is not None or
            self.Loaded_DLL_List is not None or
            self.Open_Handles_List is not None or
            self.Vad_List is not None or
            self.YaraHits is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProcessType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProcessType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProcessType'):
        if self.resultitemtype is not None and 'resultitemtype' not in already_processed:
            already_processed.add('resultitemtype')
            outfile.write(' resultitemtype="%s"' % self.gds_format_integer(self.resultitemtype, input_name='resultitemtype'))
    def exportChildren(self, outfile, level, namespace_='', name_='ProcessType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Path is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPath>%s</%sPath>%s' % (namespace_, self.gds_format_string(quote_xml(self.Path).encode(ExternalEncoding), input_name='Path'), namespace_, eol_))
        if self.StartTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTime>%s</%sStartTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.StartTime).encode(ExternalEncoding), input_name='StartTime'), namespace_, eol_))
        if self.WorkingDir is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWorkingDir>%s</%sWorkingDir>%s' % (namespace_, self.gds_format_string(quote_xml(self.WorkingDir).encode(ExternalEncoding), input_name='WorkingDir'), namespace_, eol_))
        if self.CommandLine is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCommandLine>%s</%sCommandLine>%s' % (namespace_, self.gds_format_string(quote_xml(self.CommandLine).encode(ExternalEncoding), input_name='CommandLine'), namespace_, eol_))
        if self.LinkTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLinkTime>%s</%sLinkTime>%s' % (namespace_, self.gds_format_integer(self.LinkTime, input_name='LinkTime'), namespace_, eol_))
        if self.Subsystem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubsystem>%s</%sSubsystem>%s' % (namespace_, self.gds_format_integer(self.Subsystem, input_name='Subsystem'), namespace_, eol_))
        if self.Imagebase is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImagebase>%s</%sImagebase>%s' % (namespace_, self.gds_format_integer(self.Imagebase, input_name='Imagebase'), namespace_, eol_))
        if self.Characteristics is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCharacteristics>%s</%sCharacteristics>%s' % (namespace_, self.gds_format_integer(self.Characteristics, input_name='Characteristics'), namespace_, eol_))
        if self.Checksum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChecksum>%s</%sChecksum>%s' % (namespace_, self.gds_format_integer(self.Checksum, input_name='Checksum'), namespace_, eol_))
        if self.KernelTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKernelTime>%s</%sKernelTime>%s' % (namespace_, self.gds_format_integer(self.KernelTime, input_name='KernelTime'), namespace_, eol_))
        if self.UserTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUserTime>%s</%sUserTime>%s' % (namespace_, self.gds_format_integer(self.UserTime, input_name='UserTime'), namespace_, eol_))
        if self.Privileges is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrivileges>%s</%sPrivileges>%s' % (namespace_, self.gds_format_integer(self.Privileges, input_name='Privileges'), namespace_, eol_))
        if self.PID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPID>%s</%sPID>%s' % (namespace_, self.gds_format_integer(self.PID, input_name='PID'), namespace_, eol_))
        if self.ParentPID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sParentPID>%s</%sParentPID>%s' % (namespace_, self.gds_format_integer(self.ParentPID, input_name='ParentPID'), namespace_, eol_))
        if self.User is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUser>%s</%sUser>%s' % (namespace_, self.gds_format_string(quote_xml(self.User).encode(ExternalEncoding), input_name='User'), namespace_, eol_))
        if self.Group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGroup>%s</%sGroup>%s' % (namespace_, self.gds_format_string(quote_xml(self.Group).encode(ExternalEncoding), input_name='Group'), namespace_, eol_))
        if self.MD5 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMD5>%s</%sMD5>%s' % (namespace_, self.gds_format_string(quote_xml(self.MD5).encode(ExternalEncoding), input_name='MD5'), namespace_, eol_))
        if self.SHA1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHA1>%s</%sSHA1>%s' % (namespace_, self.gds_format_string(quote_xml(self.SHA1).encode(ExternalEncoding), input_name='SHA1'), namespace_, eol_))
        if self.FuzzySize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFuzzySize>%s</%sFuzzySize>%s' % (namespace_, self.gds_format_integer(self.FuzzySize, input_name='FuzzySize'), namespace_, eol_))
        if self.Fuzzy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFuzzy>%s</%sFuzzy>%s' % (namespace_, self.gds_format_string(quote_xml(self.Fuzzy).encode(ExternalEncoding), input_name='Fuzzy'), namespace_, eol_))
        if self.Fuzzy2X is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFuzzy2X>%s</%sFuzzy2X>%s' % (namespace_, self.gds_format_string(quote_xml(self.Fuzzy2X).encode(ExternalEncoding), input_name='Fuzzy2X'), namespace_, eol_))
        if self.KFFStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKFFStatus>%s</%sKFFStatus>%s' % (namespace_, self.gds_format_integer(self.KFFStatus, input_name='KFFStatus'), namespace_, eol_))
        if self.Hidden is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHidden>%s</%sHidden>%s' % (namespace_, self.gds_format_string(quote_xml(self.Hidden).encode(ExternalEncoding), input_name='Hidden'), namespace_, eol_))
        if self.FromMemory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFromMemory>%s</%sFromMemory>%s' % (namespace_, self.gds_format_string(quote_xml(self.FromMemory).encode(ExternalEncoding), input_name='FromMemory'), namespace_, eol_))
        if self.EffectiveUser is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEffectiveUser>%s</%sEffectiveUser>%s' % (namespace_, self.gds_format_string(quote_xml(self.EffectiveUser).encode(ExternalEncoding), input_name='EffectiveUser'), namespace_, eol_))
        if self.EffectiveGroup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEffectiveGroup>%s</%sEffectiveGroup>%s' % (namespace_, self.gds_format_string(quote_xml(self.EffectiveGroup).encode(ExternalEncoding), input_name='EffectiveGroup'), namespace_, eol_))
        if self.Size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSize>%s</%sSize>%s' % (namespace_, self.gds_format_integer(self.Size, input_name='Size'), namespace_, eol_))
        if self.EProcBlockLoc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEProcBlockLoc>%s</%sEProcBlockLoc>%s' % (namespace_, self.gds_format_integer(self.EProcBlockLoc, input_name='EProcBlockLoc'), namespace_, eol_))
        if self.WindowTitle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWindowTitle>%s</%sWindowTitle>%s' % (namespace_, self.gds_format_string(_safe_encode(quote_xml(self.WindowTitle)), input_name='WindowTitle'), namespace_, eol_))
        for SDT_ in self.SDT:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSDT>%s</%sSDT>%s' % (namespace_, self.gds_format_integer(SDT_, input_name='SDT'), namespace_, eol_))
        if self.Open_Sockets_List is not None:
            self.Open_Sockets_List.export(outfile, level, namespace_, name_='Open_Sockets_List', pretty_print=pretty_print)
        if self.Loaded_DLL_List is not None:
            self.Loaded_DLL_List.export(outfile, level, namespace_, name_='Loaded_DLL_List', pretty_print=pretty_print)
        if self.Open_Handles_List is not None:
            self.Open_Handles_List.export(outfile, level, namespace_, name_='Open_Handles_List', pretty_print=pretty_print)
        if self.Vad_List is not None:
            self.Vad_List.export(outfile, level, namespace_, name_='Vad_List', pretty_print=pretty_print)
        if self.YaraHits is not None:
            self.YaraHits.export(outfile, level, namespace_, name_='YaraHits', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProcessType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.resultitemtype is not None and 'resultitemtype' not in already_processed:
            already_processed.add('resultitemtype')
            showIndent(outfile, level)
            outfile.write('resultitemtype=%d,\n' % (self.resultitemtype,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Path is not None:
            showIndent(outfile, level)
            outfile.write('Path=%s,\n' % quote_python(self.Path).encode(ExternalEncoding))
        if self.StartTime is not None:
            showIndent(outfile, level)
            outfile.write('StartTime=%s,\n' % quote_python(self.StartTime).encode(ExternalEncoding))
        if self.WorkingDir is not None:
            showIndent(outfile, level)
            outfile.write('WorkingDir=%s,\n' % quote_python(self.WorkingDir).encode(ExternalEncoding))
        if self.CommandLine is not None:
            showIndent(outfile, level)
            outfile.write('CommandLine=%s,\n' % quote_python(self.CommandLine).encode(ExternalEncoding))
        if self.LinkTime is not None:
            showIndent(outfile, level)
            outfile.write('LinkTime=%d,\n' % self.LinkTime)
        if self.Subsystem is not None:
            showIndent(outfile, level)
            outfile.write('Subsystem=%d,\n' % self.Subsystem)
        if self.Imagebase is not None:
            showIndent(outfile, level)
            outfile.write('Imagebase=%d,\n' % self.Imagebase)
        if self.Characteristics is not None:
            showIndent(outfile, level)
            outfile.write('Characteristics=%d,\n' % self.Characteristics)
        if self.Checksum is not None:
            showIndent(outfile, level)
            outfile.write('Checksum=%d,\n' % self.Checksum)
        if self.KernelTime is not None:
            showIndent(outfile, level)
            outfile.write('KernelTime=%d,\n' % self.KernelTime)
        if self.UserTime is not None:
            showIndent(outfile, level)
            outfile.write('UserTime=%d,\n' % self.UserTime)
        if self.Privileges is not None:
            showIndent(outfile, level)
            outfile.write('Privileges=%d,\n' % self.Privileges)
        if self.PID is not None:
            showIndent(outfile, level)
            outfile.write('PID=%d,\n' % self.PID)
        if self.ParentPID is not None:
            showIndent(outfile, level)
            outfile.write('ParentPID=%d,\n' % self.ParentPID)
        if self.User is not None:
            showIndent(outfile, level)
            outfile.write('User=%s,\n' % quote_python(self.User).encode(ExternalEncoding))
        if self.Group is not None:
            showIndent(outfile, level)
            outfile.write('Group=%s,\n' % quote_python(self.Group).encode(ExternalEncoding))
        if self.MD5 is not None:
            showIndent(outfile, level)
            outfile.write('MD5=%s,\n' % quote_python(self.MD5).encode(ExternalEncoding))
        if self.SHA1 is not None:
            showIndent(outfile, level)
            outfile.write('SHA1=%s,\n' % quote_python(self.SHA1).encode(ExternalEncoding))
        if self.FuzzySize is not None:
            showIndent(outfile, level)
            outfile.write('FuzzySize=%d,\n' % self.FuzzySize)
        if self.Fuzzy is not None:
            showIndent(outfile, level)
            outfile.write('Fuzzy=%s,\n' % quote_python(self.Fuzzy).encode(ExternalEncoding))
        if self.Fuzzy2X is not None:
            showIndent(outfile, level)
            outfile.write('Fuzzy2X=%s,\n' % quote_python(self.Fuzzy2X).encode(ExternalEncoding))
        if self.KFFStatus is not None:
            showIndent(outfile, level)
            outfile.write('KFFStatus=%d,\n' % self.KFFStatus)
        if self.Hidden is not None:
            showIndent(outfile, level)
            outfile.write('Hidden=%s,\n' % quote_python(self.Hidden).encode(ExternalEncoding))
        if self.FromMemory is not None:
            showIndent(outfile, level)
            outfile.write('FromMemory=%s,\n' % quote_python(self.FromMemory).encode(ExternalEncoding))
        if self.EffectiveUser is not None:
            showIndent(outfile, level)
            outfile.write('EffectiveUser=%s,\n' % quote_python(self.EffectiveUser).encode(ExternalEncoding))
        if self.EffectiveGroup is not None:
            showIndent(outfile, level)
            outfile.write('EffectiveGroup=%s,\n' % quote_python(self.EffectiveGroup).encode(ExternalEncoding))
        if self.Size is not None:
            showIndent(outfile, level)
            outfile.write('Size=%d,\n' % self.Size)
        if self.EProcBlockLoc is not None:
            showIndent(outfile, level)
            outfile.write('EProcBlockLoc=%d,\n' % self.EProcBlockLoc)
        if self.WindowTitle is not None:
            showIndent(outfile, level)
            outfile.write('WindowTitle=%s,\n' % quote_python(self.WindowTitle).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('SDT=[\n')
        level += 1
        for SDT_ in self.SDT:
            showIndent(outfile, level)
            outfile.write('%d,\n' % SDT_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Open_Sockets_List is not None:
            showIndent(outfile, level)
            outfile.write('Open_Sockets_List=model_.Open_Sockets_ListType(\n')
            self.Open_Sockets_List.exportLiteral(outfile, level, name_='Open_Sockets_List')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Loaded_DLL_List is not None:
            showIndent(outfile, level)
            outfile.write('Loaded_DLL_List=model_.Loaded_DLL_ListType(\n')
            self.Loaded_DLL_List.exportLiteral(outfile, level, name_='Loaded_DLL_List')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Open_Handles_List is not None:
            showIndent(outfile, level)
            outfile.write('Open_Handles_List=model_.Open_Handles_ListType(\n')
            self.Open_Handles_List.exportLiteral(outfile, level, name_='Open_Handles_List')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Vad_List is not None:
            showIndent(outfile, level)
            outfile.write('Vad_List=model_.Vad_ListType(\n')
            self.Vad_List.exportLiteral(outfile, level, name_='Vad_List')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.YaraHits is not None:
            showIndent(outfile, level)
            outfile.write('YaraHits=model_.YaraHitsType(\n')
            self.YaraHits.exportLiteral(outfile, level, name_='YaraHits')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resultitemtype', node)
        if value is not None and 'resultitemtype' not in already_processed:
            already_processed.add('resultitemtype')
            try:
                self.resultitemtype = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Path':
            Path_ = child_.text
            Path_ = self.gds_validate_string(Path_, node, 'Path')
            self.Path = Path_
        elif nodeName_ == 'StartTime':
            StartTime_ = child_.text
            StartTime_ = self.gds_validate_string(StartTime_, node, 'StartTime')
            self.StartTime = StartTime_
        elif nodeName_ == 'WorkingDir':
            WorkingDir_ = child_.text
            WorkingDir_ = self.gds_validate_string(WorkingDir_, node, 'WorkingDir')
            self.WorkingDir = WorkingDir_
        elif nodeName_ == 'CommandLine':
            CommandLine_ = child_.text
            CommandLine_ = self.gds_validate_string(CommandLine_, node, 'CommandLine')
            self.CommandLine = CommandLine_
        elif nodeName_ == 'LinkTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LinkTime')
            self.LinkTime = ival_
        elif nodeName_ == 'Subsystem':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Subsystem')
            self.Subsystem = ival_
        elif nodeName_ == 'Imagebase':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Imagebase')
            self.Imagebase = ival_
        elif nodeName_ == 'Characteristics':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Characteristics')
            self.Characteristics = ival_
        elif nodeName_ == 'Checksum':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Checksum')
            self.Checksum = ival_
        elif nodeName_ == 'KernelTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'KernelTime')
            self.KernelTime = ival_
        elif nodeName_ == 'UserTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UserTime')
            self.UserTime = ival_
        elif nodeName_ == 'Privileges':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Privileges')
            self.Privileges = ival_
        elif nodeName_ == 'PID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PID')
            self.PID = ival_
        elif nodeName_ == 'ParentPID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ParentPID')
            self.ParentPID = ival_
        elif nodeName_ == 'User':
            User_ = child_.text
            User_ = self.gds_validate_string(User_, node, 'User')
            self.User = User_
        elif nodeName_ == 'Group':
            Group_ = child_.text
            Group_ = self.gds_validate_string(Group_, node, 'Group')
            self.Group = Group_
        elif nodeName_ == 'MD5':
            MD5_ = child_.text
            MD5_ = self.gds_validate_string(MD5_, node, 'MD5')
            self.MD5 = MD5_
        elif nodeName_ == 'SHA1':
            SHA1_ = child_.text
            SHA1_ = self.gds_validate_string(SHA1_, node, 'SHA1')
            self.SHA1 = SHA1_
        elif nodeName_ == 'FuzzySize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FuzzySize')
            self.FuzzySize = ival_
        elif nodeName_ == 'Fuzzy':
            Fuzzy_ = child_.text
            Fuzzy_ = self.gds_validate_string(Fuzzy_, node, 'Fuzzy')
            self.Fuzzy = Fuzzy_
        elif nodeName_ == 'Fuzzy2X':
            Fuzzy2X_ = child_.text
            Fuzzy2X_ = self.gds_validate_string(Fuzzy2X_, node, 'Fuzzy2X')
            self.Fuzzy2X = Fuzzy2X_
        elif nodeName_ == 'KFFStatus':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'KFFStatus')
            self.KFFStatus = ival_
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden = Hidden_
        elif nodeName_ == 'FromMemory':
            FromMemory_ = child_.text
            FromMemory_ = self.gds_validate_string(FromMemory_, node, 'FromMemory')
            self.FromMemory = FromMemory_
        elif nodeName_ == 'EffectiveUser':
            EffectiveUser_ = child_.text
            EffectiveUser_ = self.gds_validate_string(EffectiveUser_, node, 'EffectiveUser')
            self.EffectiveUser = EffectiveUser_
        elif nodeName_ == 'EffectiveGroup':
            EffectiveGroup_ = child_.text
            EffectiveGroup_ = self.gds_validate_string(EffectiveGroup_, node, 'EffectiveGroup')
            self.EffectiveGroup = EffectiveGroup_
        elif nodeName_ == 'Size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Size')
            self.Size = ival_
        elif nodeName_ == 'EProcBlockLoc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'EProcBlockLoc')
            self.EProcBlockLoc = ival_
        elif nodeName_ == 'WindowTitle':
            WindowTitle_ = child_.text
            WindowTitle_ = self.gds_validate_string(WindowTitle_, node, 'WindowTitle')
            self.WindowTitle = WindowTitle_
        elif nodeName_ == 'SDT':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SDT')
            self.SDT.append(ival_)
        elif nodeName_ == 'Open_Sockets_List':
            obj_ = Open_Sockets_ListType.factory()
            obj_.build(child_)
            self.Open_Sockets_List = obj_
            obj_.original_tagname_ = 'Open_Sockets_List'
        elif nodeName_ == 'Loaded_DLL_List':
            obj_ = Loaded_DLL_ListType.factory()
            obj_.build(child_)
            self.Loaded_DLL_List = obj_
            obj_.original_tagname_ = 'Loaded_DLL_List'
        elif nodeName_ == 'Open_Handles_List':
            obj_ = Open_Handles_ListType.factory()
            obj_.build(child_)
            self.Open_Handles_List = obj_
            obj_.original_tagname_ = 'Open_Handles_List'
        elif nodeName_ == 'Vad_List':
            obj_ = Vad_ListType.factory()
            obj_.build(child_)
            self.Vad_List = obj_
            obj_.original_tagname_ = 'Vad_List'
        elif nodeName_ == 'YaraHits':
            obj_ = YaraHitsType.factory()
            obj_.build(child_)
            self.YaraHits = obj_
            obj_.original_tagname_ = 'YaraHits'
# end class ProcessType


class Open_Sockets_ListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Socket=None):
        self.original_tagname_ = None
        if Socket is None:
            self.Socket = []
        else:
            self.Socket = Socket
    def factory(*args_, **kwargs_):
        if Open_Sockets_ListType.subclass:
            return Open_Sockets_ListType.subclass(*args_, **kwargs_)
        else:
            return Open_Sockets_ListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Socket(self): return self.Socket
    def set_Socket(self, Socket): self.Socket = Socket
    def add_Socket(self, value): self.Socket.append(value)
    def insert_Socket_at(self, index, value): self.Socket.insert(index, value)
    def replace_Socket_at(self, index, value): self.Socket[index] = value
    def get_count(self): return len(self.Socket)
    def hasContent_(self):
        if (
            self.Socket
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Open_Sockets_ListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Open_Sockets_ListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Open_Sockets_ListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Open_Sockets_ListType'):
        if self.get_count() is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.get_count(), input_name='count'))
    def exportChildren(self, outfile, level, namespace_='', name_='Open_Sockets_ListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Socket_ in self.Socket:
            Socket_.export(outfile, level, namespace_, name_='Socket', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Open_Sockets_ListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.get_count() is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%d,\n' % (self.get_count(),))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Socket=[\n')
        level += 1
        for Socket_ in self.Socket:
            showIndent(outfile, level)
            outfile.write('model_.SocketType(\n')
            Socket_.exportLiteral(outfile, level, name_='SocketType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            # count is calculated
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Socket':
            obj_ = SocketType.factory()
            obj_.build(child_)
            self.Socket.append(obj_)
            obj_.original_tagname_ = 'Socket'
# end class Open_Sockets_ListType


class SocketType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resultitemtype=None, Port=None, LocalAddress=None, RemotePort=None, RemoteAddress=None, Proto=None, UDP=None, State=None, RealState=None, ProcessName=None, Path=None, FromMemory=None, PID=None):
        self.original_tagname_ = None
        self.resultitemtype = _cast(int, resultitemtype)
        self.Port = Port
        self.LocalAddress = LocalAddress
        self.RemotePort = RemotePort
        self.RemoteAddress = RemoteAddress
        self.Proto = Proto
        self.UDP = UDP
        self.State = State
        self.RealState = RealState
        self.ProcessName = ProcessName
        self.Path = Path
        self.FromMemory = FromMemory
        self.PID = PID
    def factory(*args_, **kwargs_):
        if SocketType.subclass:
            return SocketType.subclass(*args_, **kwargs_)
        else:
            return SocketType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def get_LocalAddress(self): return self.LocalAddress
    def set_LocalAddress(self, LocalAddress): self.LocalAddress = LocalAddress
    def get_RemotePort(self): return self.RemotePort
    def set_RemotePort(self, RemotePort): self.RemotePort = RemotePort
    def get_RemoteAddress(self): return self.RemoteAddress
    def set_RemoteAddress(self, RemoteAddress): self.RemoteAddress = RemoteAddress
    def get_Proto(self): return self.Proto
    def set_Proto(self, Proto): self.Proto = Proto
    def get_UDP(self): return self.UDP
    def set_UDP(self, UDP): self.UDP = UDP
    def get_State(self): return self.State
    def set_State(self, State): self.State = State
    def get_RealState(self): return self.RealState
    def set_RealState(self, RealState): self.RealState = RealState
    def get_ProcessName(self): return self.ProcessName
    def set_ProcessName(self, ProcessName): self.ProcessName = ProcessName
    def get_Path(self): return self.Path
    def set_Path(self, Path): self.Path = Path
    def get_FromMemory(self): return self.FromMemory
    def set_FromMemory(self, FromMemory): self.FromMemory = FromMemory
    def get_PID(self): return self.PID
    def set_PID(self, PID): self.PID = PID
    def get_resultitemtype(self): return self.resultitemtype
    def set_resultitemtype(self, resultitemtype): self.resultitemtype = resultitemtype
    def hasContent_(self):
        if (
            self.Port is not None or
            self.LocalAddress is not None or
            self.RemotePort is not None or
            self.RemoteAddress is not None or
            self.Proto is not None or
            self.UDP is not None or
            self.State is not None or
            self.RealState is not None or
            self.ProcessName is not None or
            self.Path is not None or
            self.FromMemory is not None or
            self.PID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SocketType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SocketType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SocketType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SocketType'):
        if self.resultitemtype is not None and 'resultitemtype' not in already_processed:
            already_processed.add('resultitemtype')
            outfile.write(' resultitemtype="%s"' % self.gds_format_integer(self.resultitemtype, input_name='resultitemtype'))
    def exportChildren(self, outfile, level, namespace_='', name_='SocketType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPort>%s</%sPort>%s' % (namespace_, self.gds_format_integer(self.Port, input_name='Port'), namespace_, eol_))
        if self.LocalAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocalAddress>%s</%sLocalAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.LocalAddress).encode(ExternalEncoding), input_name='LocalAddress'), namespace_, eol_))
        if self.RemotePort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRemotePort>%s</%sRemotePort>%s' % (namespace_, self.gds_format_integer(self.RemotePort, input_name='RemotePort'), namespace_, eol_))
        if self.RemoteAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRemoteAddress>%s</%sRemoteAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.RemoteAddress).encode(ExternalEncoding), input_name='RemoteAddress'), namespace_, eol_))
        if self.Proto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProto>%s</%sProto>%s' % (namespace_, self.gds_format_string(quote_xml(self.Proto).encode(ExternalEncoding), input_name='Proto'), namespace_, eol_))
        if self.UDP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUDP>%s</%sUDP>%s' % (namespace_, self.gds_format_string(quote_xml(self.UDP).encode(ExternalEncoding), input_name='UDP'), namespace_, eol_))
        if self.State is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sState>%s</%sState>%s' % (namespace_, self.gds_format_integer(self.State, input_name='State'), namespace_, eol_))
        if self.RealState is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRealState>%s</%sRealState>%s' % (namespace_, self.gds_format_integer(self.RealState, input_name='RealState'), namespace_, eol_))
        if self.ProcessName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProcessName>%s</%sProcessName>%s' % (namespace_, self.gds_format_string(quote_xml(self.ProcessName).encode(ExternalEncoding), input_name='ProcessName'), namespace_, eol_))
        if self.Path is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPath>%s</%sPath>%s' % (namespace_, self.gds_format_string(quote_xml(self.Path).encode(ExternalEncoding), input_name='Path'), namespace_, eol_))
        if self.FromMemory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFromMemory>%s</%sFromMemory>%s' % (namespace_, self.gds_format_string(quote_xml(self.FromMemory).encode(ExternalEncoding), input_name='FromMemory'), namespace_, eol_))
        if self.PID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPID>%s</%sPID>%s' % (namespace_, self.gds_format_integer(self.PID, input_name='PID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SocketType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.resultitemtype is not None and 'resultitemtype' not in already_processed:
            already_processed.add('resultitemtype')
            showIndent(outfile, level)
            outfile.write('resultitemtype=%d,\n' % (self.resultitemtype,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Port is not None:
            showIndent(outfile, level)
            outfile.write('Port=%d,\n' % self.Port)
        if self.LocalAddress is not None:
            showIndent(outfile, level)
            outfile.write('LocalAddress=%s,\n' % quote_python(self.LocalAddress).encode(ExternalEncoding))
        if self.RemotePort is not None:
            showIndent(outfile, level)
            outfile.write('RemotePort=%d,\n' % self.RemotePort)
        if self.RemoteAddress is not None:
            showIndent(outfile, level)
            outfile.write('RemoteAddress=%s,\n' % quote_python(self.RemoteAddress).encode(ExternalEncoding))
        if self.Proto is not None:
            showIndent(outfile, level)
            outfile.write('Proto=%s,\n' % quote_python(self.Proto).encode(ExternalEncoding))
        if self.UDP is not None:
            showIndent(outfile, level)
            outfile.write('UDP=%s,\n' % quote_python(self.UDP).encode(ExternalEncoding))
        if self.State is not None:
            showIndent(outfile, level)
            outfile.write('State=%d,\n' % self.State)
        if self.RealState is not None:
            showIndent(outfile, level)
            outfile.write('RealState=%d,\n' % self.RealState)
        if self.ProcessName is not None:
            showIndent(outfile, level)
            outfile.write('ProcessName=%s,\n' % quote_python(self.ProcessName).encode(ExternalEncoding))
        if self.Path is not None:
            showIndent(outfile, level)
            outfile.write('Path=%s,\n' % quote_python(self.Path).encode(ExternalEncoding))
        if self.FromMemory is not None:
            showIndent(outfile, level)
            outfile.write('FromMemory=%s,\n' % quote_python(self.FromMemory).encode(ExternalEncoding))
        if self.PID is not None:
            showIndent(outfile, level)
            outfile.write('PID=%d,\n' % self.PID)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resultitemtype', node)
        if value is not None and 'resultitemtype' not in already_processed:
            already_processed.add('resultitemtype')
            try:
                self.resultitemtype = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Port')
            self.Port = ival_
        elif nodeName_ == 'LocalAddress':
            LocalAddress_ = child_.text
            LocalAddress_ = self.gds_validate_string(LocalAddress_, node, 'LocalAddress')
            self.LocalAddress = LocalAddress_
        elif nodeName_ == 'RemotePort':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RemotePort')
            self.RemotePort = ival_
        elif nodeName_ == 'RemoteAddress':
            RemoteAddress_ = child_.text
            RemoteAddress_ = self.gds_validate_string(RemoteAddress_, node, 'RemoteAddress')
            self.RemoteAddress = RemoteAddress_
        elif nodeName_ == 'Proto':
            Proto_ = child_.text
            Proto_ = self.gds_validate_string(Proto_, node, 'Proto')
            self.Proto = Proto_
        elif nodeName_ == 'UDP':
            UDP_ = child_.text
            UDP_ = self.gds_validate_string(UDP_, node, 'UDP')
            self.UDP = UDP_
        elif nodeName_ == 'State':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'State')
            self.State = ival_
        elif nodeName_ == 'RealState':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RealState')
            self.RealState = ival_
        elif nodeName_ == 'ProcessName':
            ProcessName_ = child_.text
            ProcessName_ = self.gds_validate_string(ProcessName_, node, 'ProcessName')
            self.ProcessName = ProcessName_
        elif nodeName_ == 'Path':
            Path_ = child_.text
            Path_ = self.gds_validate_string(Path_, node, 'Path')
            self.Path = Path_
        elif nodeName_ == 'FromMemory':
            FromMemory_ = child_.text
            FromMemory_ = self.gds_validate_string(FromMemory_, node, 'FromMemory')
            self.FromMemory = FromMemory_
        elif nodeName_ == 'PID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PID')
            self.PID = ival_
# end class SocketType


class Loaded_DLL_ListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DLL=None):
        self.original_tagname_ = None
        if DLL is None:
            self.DLL = []
        else:
            self.DLL = DLL
    def factory(*args_, **kwargs_):
        if Loaded_DLL_ListType.subclass:
            return Loaded_DLL_ListType.subclass(*args_, **kwargs_)
        else:
            return Loaded_DLL_ListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DLL(self): return self.DLL
    def set_DLL(self, DLL): self.DLL = DLL
    def add_DLL(self, value): self.DLL.append(value)
    def insert_DLL_at(self, index, value): self.DLL.insert(index, value)
    def replace_DLL_at(self, index, value): self.DLL[index] = value
    def hasContent_(self):
        if (
            self.DLL
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Loaded_DLL_ListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Loaded_DLL_ListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Loaded_DLL_ListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Loaded_DLL_ListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Loaded_DLL_ListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DLL_ in self.DLL:
            DLL_.export(outfile, level, namespace_, name_='DLL', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Loaded_DLL_ListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DLL=[\n')
        level += 1
        for DLL_ in self.DLL:
            showIndent(outfile, level)
            outfile.write('model_.DLLType(\n')
            DLL_.exportLiteral(outfile, level, name_='DLLType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DLL':
            obj_ = DLLType.factory()
            obj_.build(child_)
            self.DLL.append(obj_)
            obj_.original_tagname_ = 'DLL'
# end class Loaded_DLL_ListType


class DLLType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Description=None, Path=None, Version=None, MD5=None, SHA1=None, FuzzySize=None, Fuzzy=None, Fuzzy2X=None, CreateTime=None, KFFStatus=None, PID=None, baseAddress=None, ImageSize=None, ProcessName=None, FromMemory=None):
        self.original_tagname_ = None
        self.Name = Name
        self.Description = Description
        self.Path = Path
        self.Version = Version
        self.MD5 = MD5
        self.SHA1 = SHA1
        self.FuzzySize = FuzzySize
        self.Fuzzy = Fuzzy
        self.Fuzzy2X = Fuzzy2X
        self.CreateTime = CreateTime
        self.KFFStatus = KFFStatus
        self.PID = PID
        self.baseAddress = baseAddress
        self.ImageSize = ImageSize
        self.ProcessName = ProcessName
        self.FromMemory = FromMemory
    def factory(*args_, **kwargs_):
        if DLLType.subclass:
            return DLLType.subclass(*args_, **kwargs_)
        else:
            return DLLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Path(self): return self.Path
    def set_Path(self, Path): self.Path = Path
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_MD5(self): return self.MD5
    def set_MD5(self, MD5): self.MD5 = MD5
    def get_SHA1(self): return self.SHA1
    def set_SHA1(self, SHA1): self.SHA1 = SHA1
    def get_FuzzySize(self): return self.FuzzySize
    def set_FuzzySize(self, FuzzySize): self.FuzzySize = FuzzySize
    def get_Fuzzy(self): return self.Fuzzy
    def set_Fuzzy(self, Fuzzy): self.Fuzzy = Fuzzy
    def get_Fuzzy2X(self): return self.Fuzzy2X
    def set_Fuzzy2X(self, Fuzzy2X): self.Fuzzy2X = Fuzzy2X
    def get_CreateTime(self): return self.CreateTime
    def set_CreateTime(self, CreateTime): self.CreateTime = CreateTime
    def get_KFFStatus(self): return self.KFFStatus
    def set_KFFStatus(self, KFFStatus): self.KFFStatus = KFFStatus
    def get_PID(self): return self.PID
    def set_PID(self, PID): self.PID = PID
    def get_baseAddress(self): return self.baseAddress
    def set_baseAddress(self, baseAddress): self.baseAddress = baseAddress
    def get_ImageSize(self): return self.ImageSize
    def set_ImageSize(self, ImageSize): self.ImageSize = ImageSize
    def get_ProcessName(self): return self.ProcessName
    def set_ProcessName(self, ProcessName): self.ProcessName = ProcessName
    def get_FromMemory(self): return self.FromMemory
    def set_FromMemory(self, FromMemory): self.FromMemory = FromMemory
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Description is not None or
            self.Path is not None or
            self.Version is not None or
            self.MD5 is not None or
            self.SHA1 is not None or
            self.FuzzySize is not None or
            self.Fuzzy is not None or
            self.Fuzzy2X is not None or
            self.CreateTime is not None or
            self.KFFStatus is not None or
            self.PID is not None or
            self.baseAddress is not None or
            self.ImageSize is not None or
            self.ProcessName is not None or
            self.FromMemory is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DLLType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DLLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DLLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DLLType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DLLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(_safe_encode(quote_xml(self.Name)), input_name='Name'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(_safe_encode(quote_xml(self.Description)), input_name='Description'), namespace_, eol_))
        if self.Path is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPath>%s</%sPath>%s' % (namespace_, self.gds_format_string(_safe_encode(quote_xml(self.Path)), input_name='Path'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.MD5 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMD5>%s</%sMD5>%s' % (namespace_, self.gds_format_string(quote_xml(self.MD5).encode(ExternalEncoding), input_name='MD5'), namespace_, eol_))
        if self.SHA1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHA1>%s</%sSHA1>%s' % (namespace_, self.gds_format_string(quote_xml(self.SHA1).encode(ExternalEncoding), input_name='SHA1'), namespace_, eol_))
        if self.FuzzySize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFuzzySize>%s</%sFuzzySize>%s' % (namespace_, self.gds_format_integer(self.FuzzySize, input_name='FuzzySize'), namespace_, eol_))
        if self.Fuzzy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFuzzy>%s</%sFuzzy>%s' % (namespace_, self.gds_format_string(quote_xml(self.Fuzzy).encode(ExternalEncoding), input_name='Fuzzy'), namespace_, eol_))
        if self.Fuzzy2X is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFuzzy2X>%s</%sFuzzy2X>%s' % (namespace_, self.gds_format_string(quote_xml(self.Fuzzy2X).encode(ExternalEncoding), input_name='Fuzzy2X'), namespace_, eol_))
        if self.CreateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreateTime>%s</%sCreateTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.CreateTime).encode(ExternalEncoding), input_name='CreateTime'), namespace_, eol_))
        if self.KFFStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKFFStatus>%s</%sKFFStatus>%s' % (namespace_, self.gds_format_integer(self.KFFStatus, input_name='KFFStatus'), namespace_, eol_))
        if self.PID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPID>%s</%sPID>%s' % (namespace_, self.gds_format_integer(self.PID, input_name='PID'), namespace_, eol_))
        if self.baseAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbaseAddress>%s</%sbaseAddress>%s' % (namespace_, self.gds_format_integer(self.baseAddress, input_name='baseAddress'), namespace_, eol_))
        if self.ImageSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageSize>%s</%sImageSize>%s' % (namespace_, self.gds_format_integer(self.ImageSize, input_name='ImageSize'), namespace_, eol_))
        if self.ProcessName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProcessName>%s</%sProcessName>%s' % (namespace_, self.gds_format_string(quote_xml(self.ProcessName).encode(ExternalEncoding), input_name='ProcessName'), namespace_, eol_))
        if self.FromMemory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFromMemory>%s</%sFromMemory>%s' % (namespace_, self.gds_format_string(quote_xml(self.FromMemory).encode(ExternalEncoding), input_name='FromMemory'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DLLType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Path is not None:
            showIndent(outfile, level)
            outfile.write('Path=%s,\n' % quote_python(self.Path).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.MD5 is not None:
            showIndent(outfile, level)
            outfile.write('MD5=%s,\n' % quote_python(self.MD5).encode(ExternalEncoding))
        if self.SHA1 is not None:
            showIndent(outfile, level)
            outfile.write('SHA1=%s,\n' % quote_python(self.SHA1).encode(ExternalEncoding))
        if self.FuzzySize is not None:
            showIndent(outfile, level)
            outfile.write('FuzzySize=%d,\n' % self.FuzzySize)
        if self.Fuzzy is not None:
            showIndent(outfile, level)
            outfile.write('Fuzzy=%s,\n' % quote_python(self.Fuzzy).encode(ExternalEncoding))
        if self.Fuzzy2X is not None:
            showIndent(outfile, level)
            outfile.write('Fuzzy2X=%s,\n' % quote_python(self.Fuzzy2X).encode(ExternalEncoding))
        if self.CreateTime is not None:
            showIndent(outfile, level)
            outfile.write('CreateTime=%s,\n' % quote_python(self.CreateTime).encode(ExternalEncoding))
        if self.KFFStatus is not None:
            showIndent(outfile, level)
            outfile.write('KFFStatus=%d,\n' % self.KFFStatus)
        if self.PID is not None:
            showIndent(outfile, level)
            outfile.write('PID=%d,\n' % self.PID)
        if self.baseAddress is not None:
            showIndent(outfile, level)
            outfile.write('baseAddress=%d,\n' % self.baseAddress)
        if self.ImageSize is not None:
            showIndent(outfile, level)
            outfile.write('ImageSize=%d,\n' % self.ImageSize)
        if self.ProcessName is not None:
            showIndent(outfile, level)
            outfile.write('ProcessName=%s,\n' % quote_python(self.ProcessName).encode(ExternalEncoding))
        if self.FromMemory is not None:
            showIndent(outfile, level)
            outfile.write('FromMemory=%s,\n' % quote_python(self.FromMemory).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Path':
            Path_ = child_.text
            Path_ = self.gds_validate_string(Path_, node, 'Path')
            self.Path = Path_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
        elif nodeName_ == 'MD5':
            MD5_ = child_.text
            MD5_ = self.gds_validate_string(MD5_, node, 'MD5')
            self.MD5 = MD5_
        elif nodeName_ == 'SHA1':
            SHA1_ = child_.text
            SHA1_ = self.gds_validate_string(SHA1_, node, 'SHA1')
            self.SHA1 = SHA1_
        elif nodeName_ == 'FuzzySize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FuzzySize')
            self.FuzzySize = ival_
        elif nodeName_ == 'Fuzzy':
            Fuzzy_ = child_.text
            Fuzzy_ = self.gds_validate_string(Fuzzy_, node, 'Fuzzy')
            self.Fuzzy = Fuzzy_
        elif nodeName_ == 'Fuzzy2X':
            Fuzzy2X_ = child_.text
            Fuzzy2X_ = self.gds_validate_string(Fuzzy2X_, node, 'Fuzzy2X')
            self.Fuzzy2X = Fuzzy2X_
        elif nodeName_ == 'CreateTime':
            CreateTime_ = child_.text
            CreateTime_ = self.gds_validate_string(CreateTime_, node, 'CreateTime')
            self.CreateTime = CreateTime_
        elif nodeName_ == 'KFFStatus':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'KFFStatus')
            self.KFFStatus = ival_
        elif nodeName_ == 'PID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PID')
            self.PID = ival_
        elif nodeName_ == 'baseAddress':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'baseAddress')
            self.baseAddress = ival_
        elif nodeName_ == 'ImageSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ImageSize')
            self.ImageSize = ival_
        elif nodeName_ == 'ProcessName':
            ProcessName_ = child_.text
            ProcessName_ = self.gds_validate_string(ProcessName_, node, 'ProcessName')
            self.ProcessName = ProcessName_
        elif nodeName_ == 'FromMemory':
            FromMemory_ = child_.text
            FromMemory_ = self.gds_validate_string(FromMemory_, node, 'FromMemory')
            self.FromMemory = FromMemory_
# end class DLLType


class Open_Handles_ListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OpenHandle=None):
        self.original_tagname_ = None
        if OpenHandle is None:
            self.OpenHandle = []
        else:
            self.OpenHandle = OpenHandle
    def factory(*args_, **kwargs_):
        if Open_Handles_ListType.subclass:
            return Open_Handles_ListType.subclass(*args_, **kwargs_)
        else:
            return Open_Handles_ListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpenHandle(self): return self.OpenHandle
    def set_OpenHandle(self, OpenHandle): self.OpenHandle = OpenHandle
    def add_OpenHandle(self, value): self.OpenHandle.append(value)
    def insert_OpenHandle_at(self, index, value): self.OpenHandle.insert(index, value)
    def replace_OpenHandle_at(self, index, value): self.OpenHandle[index] = value
    def hasContent_(self):
        if (
            self.OpenHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Open_Handles_ListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Open_Handles_ListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Open_Handles_ListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Open_Handles_ListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Open_Handles_ListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OpenHandle_ in self.OpenHandle:
            OpenHandle_.export(outfile, level, namespace_, name_='OpenHandle', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Open_Handles_ListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('OpenHandle=[\n')
        level += 1
        for OpenHandle_ in self.OpenHandle:
            showIndent(outfile, level)
            outfile.write('model_.OpenHandleType(\n')
            OpenHandle_.exportLiteral(outfile, level, name_='OpenHandleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpenHandle':
            obj_ = OpenHandleType.factory()
            obj_.build(child_)
            self.OpenHandle.append(obj_)
            obj_.original_tagname_ = 'OpenHandle'
# end class Open_Handles_ListType


class OpenHandleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Type=None, Path=None, AccessMask=None, Name=None, PID=None, PointerCount=None, ObjectAddress=None, FromMemory=None, Owner=None, Group=None, Permissions=None):
        self.original_tagname_ = None
        self.ID = ID
        self.Type = Type
        self.Path = Path
        self.AccessMask = AccessMask
        self.Name = Name
        self.PID = PID
        self.PointerCount = PointerCount
        self.ObjectAddress = ObjectAddress
        self.FromMemory = FromMemory
        self.Owner = Owner
        self.Group = Group
        self.Permissions = Permissions
    def factory(*args_, **kwargs_):
        if OpenHandleType.subclass:
            return OpenHandleType.subclass(*args_, **kwargs_)
        else:
            return OpenHandleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Path(self): return self.Path
    def set_Path(self, Path): self.Path = Path
    def get_AccessMask(self): return self.AccessMask
    def set_AccessMask(self, AccessMask): self.AccessMask = AccessMask
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_PID(self): return self.PID
    def set_PID(self, PID): self.PID = PID
    def get_PointerCount(self): return self.PointerCount
    def set_PointerCount(self, PointerCount): self.PointerCount = PointerCount
    def get_ObjectAddress(self): return self.ObjectAddress
    def set_ObjectAddress(self, ObjectAddress): self.ObjectAddress = ObjectAddress
    def get_FromMemory(self): return self.FromMemory
    def set_FromMemory(self, FromMemory): self.FromMemory = FromMemory
    def get_Owner(self): return self.Owner
    def set_Owner(self, Owner): self.Owner = Owner
    def get_Group(self): return self.Group
    def set_Group(self, Group): self.Group = Group
    def get_Permissions(self): return self.Permissions
    def set_Permissions(self, Permissions): self.Permissions = Permissions
    def hasContent_(self):
        if (
            self.ID is not None or
            self.Type is not None or
            self.Path is not None or
            self.AccessMask is not None or
            self.Name is not None or
            self.PID is not None or
            self.PointerCount is not None or
            self.ObjectAddress is not None or
            self.FromMemory is not None or
            self.Owner is not None or
            self.Group is not None or
            self.Permissions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OpenHandleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OpenHandleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OpenHandleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OpenHandleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OpenHandleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_integer(self.ID, input_name='ID'), namespace_, eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespace_, self.gds_format_string(quote_xml(self.Type).encode(ExternalEncoding), input_name='Type'), namespace_, eol_))
        if self.Path is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPath>%s</%sPath>%s' % (namespace_, self.gds_format_string(_safe_encode(quote_xml(self.Path)), input_name='Path'), namespace_, eol_))
        if self.AccessMask is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccessMask>%s</%sAccessMask>%s' % (namespace_, self.gds_format_integer(self.AccessMask, input_name='AccessMask'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.PID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPID>%s</%sPID>%s' % (namespace_, self.gds_format_integer(self.PID, input_name='PID'), namespace_, eol_))
        if self.PointerCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPointerCount>%s</%sPointerCount>%s' % (namespace_, self.gds_format_integer(self.PointerCount, input_name='PointerCount'), namespace_, eol_))
        if self.ObjectAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sObjectAddress>%s</%sObjectAddress>%s' % (namespace_, self.gds_format_integer(self.ObjectAddress, input_name='ObjectAddress'), namespace_, eol_))
        if self.FromMemory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFromMemory>%s</%sFromMemory>%s' % (namespace_, self.gds_format_string(quote_xml(self.FromMemory).encode(ExternalEncoding), input_name='FromMemory'), namespace_, eol_))
        if self.Owner is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOwner>%s</%sOwner>%s' % (namespace_, self.gds_format_string(quote_xml(self.Owner).encode(ExternalEncoding), input_name='Owner'), namespace_, eol_))
        if self.Group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGroup>%s</%sGroup>%s' % (namespace_, self.gds_format_string(quote_xml(self.Group).encode(ExternalEncoding), input_name='Group'), namespace_, eol_))
        if self.Permissions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPermissions>%s</%sPermissions>%s' % (namespace_, self.gds_format_string(quote_xml(self.Permissions).encode(ExternalEncoding), input_name='Permissions'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OpenHandleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%d,\n' % self.ID)
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % quote_python(self.Type).encode(ExternalEncoding))
        if self.Path is not None:
            showIndent(outfile, level)
            outfile.write('Path=%s,\n' % quote_python(self.Path).encode(ExternalEncoding))
        if self.AccessMask is not None:
            showIndent(outfile, level)
            outfile.write('AccessMask=%d,\n' % self.AccessMask)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.PID is not None:
            showIndent(outfile, level)
            outfile.write('PID=%d,\n' % self.PID)
        if self.PointerCount is not None:
            showIndent(outfile, level)
            outfile.write('PointerCount=%d,\n' % self.PointerCount)
        if self.ObjectAddress is not None:
            showIndent(outfile, level)
            outfile.write('ObjectAddress=%d,\n' % self.ObjectAddress)
        if self.FromMemory is not None:
            showIndent(outfile, level)
            outfile.write('FromMemory=%s,\n' % quote_python(self.FromMemory).encode(ExternalEncoding))
        if self.Owner is not None:
            showIndent(outfile, level)
            outfile.write('Owner=%s,\n' % quote_python(self.Owner).encode(ExternalEncoding))
        if self.Group is not None:
            showIndent(outfile, level)
            outfile.write('Group=%s,\n' % quote_python(self.Group).encode(ExternalEncoding))
        if self.Permissions is not None:
            showIndent(outfile, level)
            outfile.write('Permissions=%s,\n' % quote_python(self.Permissions).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'Path':
            Path_ = child_.text
            Path_ = self.gds_validate_string(Path_, node, 'Path')
            self.Path = Path_
        elif nodeName_ == 'AccessMask':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AccessMask')
            self.AccessMask = ival_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'PID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PID')
            self.PID = ival_
        elif nodeName_ == 'PointerCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PointerCount')
            self.PointerCount = ival_
        elif nodeName_ == 'ObjectAddress':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ObjectAddress')
            self.ObjectAddress = ival_
        elif nodeName_ == 'FromMemory':
            FromMemory_ = child_.text
            FromMemory_ = self.gds_validate_string(FromMemory_, node, 'FromMemory')
            self.FromMemory = FromMemory_
        elif nodeName_ == 'Owner':
            Owner_ = child_.text
            Owner_ = self.gds_validate_string(Owner_, node, 'Owner')
            self.Owner = Owner_
        elif nodeName_ == 'Group':
            Group_ = child_.text
            Group_ = self.gds_validate_string(Group_, node, 'Group')
            self.Group = Group_
        elif nodeName_ == 'Permissions':
            Permissions_ = child_.text
            Permissions_ = self.gds_validate_string(Permissions_, node, 'Permissions')
            self.Permissions = Permissions_
# end class OpenHandleType


class Vad_ListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Vad=None):
        self.original_tagname_ = None
        if Vad is None:
            self.Vad = []
        else:
            self.Vad = Vad
    def factory(*args_, **kwargs_):
        if Vad_ListType.subclass:
            return Vad_ListType.subclass(*args_, **kwargs_)
        else:
            return Vad_ListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Vad(self): return self.Vad
    def set_Vad(self, Vad): self.Vad = Vad
    def add_Vad(self, value): self.Vad.append(value)
    def insert_Vad_at(self, index, value): self.Vad.insert(index, value)
    def replace_Vad_at(self, index, value): self.Vad[index] = value
    def hasContent_(self):
        if (
            self.Vad
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Vad_ListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Vad_ListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Vad_ListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Vad_ListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Vad_ListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Vad_ in self.Vad:
            Vad_.export(outfile, level, namespace_, name_='Vad', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Vad_ListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Vad=[\n')
        level += 1
        for Vad_ in self.Vad:
            showIndent(outfile, level)
            outfile.write('model_.VadType(\n')
            Vad_.exportLiteral(outfile, level, name_='VadType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Vad':
            obj_ = VadType.factory()
            obj_.build(child_)
            self.Vad.append(obj_)
            obj_.original_tagname_ = 'Vad'
# end class Vad_ListType


class VadType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Protection=None, StartVpn=None, EndVpn=None, Address=None, Flags=None, Mapped=None, Filename=None, Suspicious=None, ProcessName=None, PID=None, FromMemory=None):
        self.original_tagname_ = None
        self.Protection = Protection
        self.StartVpn = StartVpn
        self.EndVpn = EndVpn
        self.Address = Address
        self.Flags = Flags
        self.Mapped = Mapped
        self.Filename = Filename
        self.Suspicious = Suspicious
        self.ProcessName = ProcessName
        self.PID = PID
        self.FromMemory = FromMemory
    def factory(*args_, **kwargs_):
        if VadType.subclass:
            return VadType.subclass(*args_, **kwargs_)
        else:
            return VadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Protection(self): return self.Protection
    def set_Protection(self, Protection): self.Protection = Protection
    def get_StartVpn(self): return self.StartVpn
    def set_StartVpn(self, StartVpn): self.StartVpn = StartVpn
    def get_EndVpn(self): return self.EndVpn
    def set_EndVpn(self, EndVpn): self.EndVpn = EndVpn
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Flags(self): return self.Flags
    def set_Flags(self, Flags): self.Flags = Flags
    def get_Mapped(self): return self.Mapped
    def set_Mapped(self, Mapped): self.Mapped = Mapped
    def get_Filename(self): return self.Filename
    def set_Filename(self, Filename): self.Filename = Filename
    def get_Suspicious(self): return self.Suspicious
    def set_Suspicious(self, Suspicious): self.Suspicious = Suspicious
    def get_ProcessName(self): return self.ProcessName
    def set_ProcessName(self, ProcessName): self.ProcessName = ProcessName
    def get_PID(self): return self.PID
    def set_PID(self, PID): self.PID = PID
    def get_FromMemory(self): return self.FromMemory
    def set_FromMemory(self, FromMemory): self.FromMemory = FromMemory
    def hasContent_(self):
        if (
            self.Protection is not None or
            self.StartVpn is not None or
            self.EndVpn is not None or
            self.Address is not None or
            self.Flags is not None or
            self.Mapped is not None or
            self.Filename is not None or
            self.Suspicious is not None or
            self.ProcessName is not None or
            self.PID is not None or
            self.FromMemory is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VadType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VadType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VadType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VadType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VadType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Protection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtection>%s</%sProtection>%s' % (namespace_, self.gds_format_integer(self.Protection, input_name='Protection'), namespace_, eol_))
        if self.StartVpn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartVpn>%s</%sStartVpn>%s' % (namespace_, self.gds_format_integer(self.StartVpn, input_name='StartVpn'), namespace_, eol_))
        if self.EndVpn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndVpn>%s</%sEndVpn>%s' % (namespace_, self.gds_format_integer(self.EndVpn, input_name='EndVpn'), namespace_, eol_))
        if self.Address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddress>%s</%sAddress>%s' % (namespace_, self.gds_format_integer(self.Address, input_name='Address'), namespace_, eol_))
        if self.Flags is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFlags>%s</%sFlags>%s' % (namespace_, self.gds_format_integer(self.Flags, input_name='Flags'), namespace_, eol_))
        if self.Mapped is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMapped>%s</%sMapped>%s' % (namespace_, self.gds_format_string(quote_xml(self.Mapped).encode(ExternalEncoding), input_name='Mapped'), namespace_, eol_))
        if self.Filename is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFilename>%s</%sFilename>%s' % (namespace_, self.gds_format_string(_safe_encode(quote_xml(self.Filename)), input_name='Filename'), namespace_, eol_))
        if self.Suspicious is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSuspicious>%s</%sSuspicious>%s' % (namespace_, self.gds_format_string(quote_xml(self.Suspicious).encode(ExternalEncoding), input_name='Suspicious'), namespace_, eol_))
        if self.ProcessName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProcessName>%s</%sProcessName>%s' % (namespace_, self.gds_format_string(quote_xml(self.ProcessName).encode(ExternalEncoding), input_name='ProcessName'), namespace_, eol_))
        if self.PID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPID>%s</%sPID>%s' % (namespace_, self.gds_format_integer(self.PID, input_name='PID'), namespace_, eol_))
        if self.FromMemory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFromMemory>%s</%sFromMemory>%s' % (namespace_, self.gds_format_string(quote_xml(self.FromMemory).encode(ExternalEncoding), input_name='FromMemory'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VadType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Protection is not None:
            showIndent(outfile, level)
            outfile.write('Protection=%d,\n' % self.Protection)
        if self.StartVpn is not None:
            showIndent(outfile, level)
            outfile.write('StartVpn=%d,\n' % self.StartVpn)
        if self.EndVpn is not None:
            showIndent(outfile, level)
            outfile.write('EndVpn=%d,\n' % self.EndVpn)
        if self.Address is not None:
            showIndent(outfile, level)
            outfile.write('Address=%d,\n' % self.Address)
        if self.Flags is not None:
            showIndent(outfile, level)
            outfile.write('Flags=%d,\n' % self.Flags)
        if self.Mapped is not None:
            showIndent(outfile, level)
            outfile.write('Mapped=%s,\n' % quote_python(self.Mapped).encode(ExternalEncoding))
        if self.Filename is not None:
            showIndent(outfile, level)
            outfile.write('Filename=%s,\n' % quote_python(self.Filename).encode(ExternalEncoding))
        if self.Suspicious is not None:
            showIndent(outfile, level)
            outfile.write('Suspicious=%s,\n' % quote_python(self.Suspicious).encode(ExternalEncoding))
        if self.ProcessName is not None:
            showIndent(outfile, level)
            outfile.write('ProcessName=%s,\n' % quote_python(self.ProcessName).encode(ExternalEncoding))
        if self.PID is not None:
            showIndent(outfile, level)
            outfile.write('PID=%d,\n' % self.PID)
        if self.FromMemory is not None:
            showIndent(outfile, level)
            outfile.write('FromMemory=%s,\n' % quote_python(self.FromMemory).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Protection':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Protection')
            self.Protection = ival_
        elif nodeName_ == 'StartVpn':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StartVpn')
            self.StartVpn = ival_
        elif nodeName_ == 'EndVpn':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'EndVpn')
            self.EndVpn = ival_
        elif nodeName_ == 'Address':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Address')
            self.Address = ival_
        elif nodeName_ == 'Flags':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Flags')
            self.Flags = ival_
        elif nodeName_ == 'Mapped':
            Mapped_ = child_.text
            Mapped_ = self.gds_validate_string(Mapped_, node, 'Mapped')
            self.Mapped = Mapped_
        elif nodeName_ == 'Filename':
            Filename_ = child_.text
            Filename_ = self.gds_validate_string(Filename_, node, 'Filename')
            self.Filename = Filename_
        elif nodeName_ == 'Suspicious':
            Suspicious_ = child_.text
            Suspicious_ = self.gds_validate_string(Suspicious_, node, 'Suspicious')
            self.Suspicious = Suspicious_
        elif nodeName_ == 'ProcessName':
            ProcessName_ = child_.text
            ProcessName_ = self.gds_validate_string(ProcessName_, node, 'ProcessName')
            self.ProcessName = ProcessName_
        elif nodeName_ == 'PID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PID')
            self.PID = ival_
        elif nodeName_ == 'FromMemory':
            FromMemory_ = child_.text
            FromMemory_ = self.gds_validate_string(FromMemory_, node, 'FromMemory')
            self.FromMemory = FromMemory_
# end class VadType


class YaraHitsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, YaraHit=None):
        self.original_tagname_ = None
        if YaraHit is None:
            self.YaraHit = []
        else:
            self.YaraHit = YaraHit
    def factory(*args_, **kwargs_):
        if YaraHitsType.subclass:
            return YaraHitsType.subclass(*args_, **kwargs_)
        else:
            return YaraHitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_YaraHit(self): return self.YaraHit
    def set_YaraHit(self, YaraHit): self.YaraHit = YaraHit
    def add_YaraHit(self, value): self.YaraHit.append(value)
    def insert_YaraHit_at(self, index, value): self.YaraHit.insert(index, value)
    def replace_YaraHit_at(self, index, value): self.YaraHit[index] = value
    def hasContent_(self):
        if (
            self.YaraHit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='YaraHitsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='YaraHitsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='YaraHitsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='YaraHitsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='YaraHitsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for YaraHit_ in self.YaraHit:
            YaraHit_.export(outfile, level, namespace_, name_='YaraHit', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='YaraHitsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('YaraHit=[\n')
        level += 1
        for YaraHit_ in self.YaraHit:
            showIndent(outfile, level)
            outfile.write('model_.YaraHitType(\n')
            YaraHit_.exportLiteral(outfile, level, name_='YaraHitType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'YaraHit':
            obj_ = YaraHitType.factory()
            obj_.build(child_)
            self.YaraHit.append(obj_)
            obj_.original_tagname_ = 'YaraHit'
# end class YaraHitsType


class YaraHitType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, Name=None, Category=None):
        self.original_tagname_ = None
        self.id = id
        self.Name = Name
        self.Category = Category
    def factory(*args_, **kwargs_):
        if YaraHitType.subclass:
            return YaraHitType.subclass(*args_, **kwargs_)
        else:
            return YaraHitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def hasContent_(self):
        if (
            self.id is not None or
            self.Name is not None or
            self.Category is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='YaraHitType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='YaraHitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='YaraHitType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='YaraHitType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='YaraHitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_string(quote_xml(self.id).encode(ExternalEncoding), input_name='id'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Category is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategory>%s</%sCategory>%s' % (namespace_, self.gds_format_string(quote_xml(self.Category).encode(ExternalEncoding), input_name='Category'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='YaraHitType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % quote_python(self.id).encode(ExternalEncoding))
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Category is not None:
            showIndent(outfile, level)
            outfile.write('Category=%s,\n' % quote_python(self.Category).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Category':
            Category_ = child_.text
            Category_ = self.gds_validate_string(Category_, node, 'Category')
            self.Category = Category_
# end class YaraHitType


GDSClassesMapping = {
    'OpenHandle': OpenHandleType,
    'Socket': SocketType,
    'Open_Sockets_List': Open_Sockets_ListType,
    'Process': ProcessType,
    'YaraHit': YaraHitType,
    'Vad': VadType,
    'DLL': DLLType,
    'Vad_List': Vad_ListType,
    'Open_Handles_List': Open_Handles_ListType,
    'YaraHits': YaraHitsType,
    'Loaded_DLL_List': Loaded_DLL_ListType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'root'
        rootClass = root
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'root'
        rootClass = root
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'root'
        rootClass = root
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'root'
        rootClass = root
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from processdatastructure import *\n\n')
        sys.stdout.write('import processdatastructure as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "DLLType",
    "Loaded_DLL_ListType",
    "OpenHandleType",
    "Open_Handles_ListType",
    "Open_Sockets_ListType",
    "ProcessType",
    "SocketType",
    "VadType",
    "Vad_ListType",
    "YaraHitType",
    "YaraHitsType",
    "root"
]
